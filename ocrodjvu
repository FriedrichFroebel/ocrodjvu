#!/usr/bin/python
# encoding=UTF-8
# Copyright Â© 2008 Jakub Wilk <ubanus@users.sf.net>
#
# This package is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

__version__ = '0.1.3'

import sys
import tempfile
import subprocess
import shutil
import os.path
import optparse

import djvu.decode

import hocr

PIXEL_FORMAT = djvu.decode.PixelFormatPackedBits('>')
PIXEL_FORMAT.rows_top_to_bottom = 1
PIXEL_FORMAT.y_top_to_bottom = 1

try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, return_code, command):
            Exception.__init__(self, command, return_code)
        def __str__(self):
            return 'Command %r returned non-zero exit status %d' % self.args
    subprocess.CalledProcessError = CalledProcessError
del CalledProcessError

class OptionParser(optparse.OptionParser):
    def __init__(self):
        usage = '%prog [options] <djvu-file>'
        version = '%%prog %s' % __version__
        optparse.OptionParser.__init__(self, usage=usage, version=version)
        self.add_option('-p', '--pages', dest='pages', action='store', default=None)
        self.add_option('-D', '--debug', dest='debug', action='store_true', default=False, help='''don't delete intermediate files''')
    
    def parse_args(self):
        try:
            options, [path] = optparse.OptionParser.parse_args(self)
        except ValueError:
            self.error('Invalid number of arguments')
        try:
            if options.pages is not None:
                pages = []
                for range in options.pages.split(','):
                    if '-' in range:
                        x, y = map(int, options.pages.split('-', 1))
                        pages += xrange(x, y + 1)
                    else:
                        pages += int(range),
                options.pages = pages
        except (TypeError, ValueError):
            self.error('Unable to parse page numbers')
        return options, path

class Subprocess(subprocess.Popen):

    def __init__(self, *args, **kwargs):
        subprocess.Popen.__init__(self, *args, **kwargs)
        try:
            self.__command = kwargs['args'][0]
        except KeyError:
            self.__command = args[0][0]

    def wait(self):
        return_code = subprocess.Popen.wait(self)
        if return_code != 0:
            raise subprocess.CalledProcessError(return_code, self.__command)

class Context(djvu.decode.Context):

    def init(self, debug):
        self._temp_dir = tempfile.mkdtemp(prefix='ocrodjvu.')
        self._debug = debug

    def _temp_file(self, name):
        path = os.path.join(self._temp_dir, name)
        file = open(path, 'w+b')
        if not self._debug:
            file = tempfile._TemporaryFileWrapper(file, file.name)
        return file

    def handle_message(self, message):
        if isinstance(message, djvu.decode.ErrorMessage):
            print >>sys.stderr, message
            sys.exit(1)

    def process_page(self, page):
        print >>sys.stderr, '- Page #%d' % (page.n + 1)
        page_job = page.decode(wait=True)
        size = page_job.size
        rect = (0, 0) + size
        pfile = self._temp_file('%06d.pbm' % page.n)
        try:
            pfile.write('P4 %d %d\n' % size) # PBM header
            data = page_job.render(
                djvu.decode.RENDER_MASK_ONLY,
                rect, rect,
                PIXEL_FORMAT
            )
            pfile.write(data)
            pfile.flush()
            ocropus = Subprocess(['ocroscript', 'rec-tess', pfile.name], stdout=subprocess.PIPE)
            html_file = None
            try:
                if self._debug:
                    html_file = self._temp_file('%06d.html' % page.n)
                    html = ocropus.stdout.read()
                    html_file.write(html)
                    html_file.seek(0)
                else:
                    html_file = ocropus.stdout
                text, = hocr.extract_text(html_file, page.rotation)
                return text
            finally:
                if html_file is not None:
                    html_file.close()
                ocropus.wait()
        finally:
            pfile.close()

    def process(self, path, pages = None):
        print >>sys.stderr, 'Processing %r:' % path
        document = self.new_document(djvu.decode.FileURI(path))
        document.decoding_job.wait()
        if pages is None:
            pages = iter(document.pages)
        else:
            pages = (document.pages[i-1] for i in pages)
        sed_file = self._temp_file('ocrodjvu.djvused')
        try:
            sed_file.write('remove-txt\n')
            for page in pages:
                sed_file.write('select %d\n' % (page.n + 1))
                sed_file.write('set-txt\n')
                try:
                    self.process_page(page).print_into(sed_file)
                except djvu.decode.NotAvailable:
                    print >>sys.stderr, 'No image suitable for OCR.'
                sed_file.write('\n.\n\n')
            sed_file.flush()
            document = None
            path = os.path.abspath(path)
            djvused = Subprocess(['djvused', '-s', '-f', sed_file.name, path])
            djvused.wait()
        finally:
            sed_file.close()

    def close(self):
        if self._debug:
            return self._temp_dir
        else:
            shutil.rmtree(self._temp_dir)

def main():
    oparser = OptionParser()
    options, path = oparser.parse_args()
    context = Context()
    context.init(options.debug)
    try:
        context.process(path, options.pages)
    finally:
        temp_dir = context.close()
        if temp_dir is not None:
            print >>sys.stderr, 'Intermediate files were left in the %r directory.' % temp_dir

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
